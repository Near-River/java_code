一：注解 Annotation
	作用：不是程序本身，可以对程序作出解释
		  可以被其他程序（解释器等）读取 （注解信息处理流程）
	* 通过反射机制编程实现对元数据的访问
	系统常用注解：@Override  @Deprecated  @SuppressWarnings // 抑制警告信息

	自定义注解：public @interface 注解名 {定义体}
	元注解：@Target：描述注解使用范围  ElementType
		  @Retention：描述注解的生命周期  RetentionPolicy
		  @Documented：生成 Javadoc 时会包含注解
		  @Inherited：允许子类继承

二：动态性
	反射机制（refection）：
		在运行时加载、探知、使用编译期间完全未知的类
		程序在运行状态时，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道
			这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性
		在加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（* 一个类只有一个 Class 对象），
			这个对象就包含了完整的类的结构信息
		setAccessible：启动和禁用访问安全检查的开关
		编译完成后，所有与泛型有关的类型全部檫除
			ParameterizedType  GenericArrayType  TypeVariable  WildcardType

	动态编译：
		JavaCompiler：
			JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
			int result = compiler.run(null, null, null, sourceFile);
			// 第一个参数：为 Java 编译器提供参数   第二个参数：得到 java 编译器的输出信息
			// 第三个参数：接收编译器的错误信息     第四个参数：可变参数，可以接受多个 java 源文件
			// 返回值：0 便是编译成功，非 0 便是编译失败

	脚本引擎执行 JavaScript：Phino
		Java 脚本 API 是连接 Java 平台和脚本语言的桥梁
		通过脚本引擎的运行上下文在脚本和 Java 平台间交换数据

	动态字节码操作（JAVAssist）：
        优点：比反射开销小、性能高
        用途：动态生成新的类、动态改变某个类的结构（添加/删除/修改）
        操作类库：BCEL、ASM、CGLIB、JAVAssist

        JAVAssist：CtClass、CtMethod、CtField

三：JVM 运行和类加载器
	类加载机制：
		加载 --> 链接（验证、准备、解析） --> 初始化（使用、解载）
		加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换为方法区中的运行时数据结构，
			在堆中生成一个代表这个类的 Class 对象，作为方法区类数据的访问入口。（需类加载器参与）
        链接：将 Java 类的二进制码合并到 JVM 的运行状态之中的过程
            验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题
            准备：正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区中进行分配
            解析：虚拟机常量池内的符号引用替换为直接引用的过程
        初始化：是执行类构造器<clinit>()方法的过程。类构造器方法由编译器自动收集类中的所有类变量的
                赋值动作和静态语句块中的语句合并产生的
               当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
               虚拟机会保证一个类的 *<clinit>()方法在多线程环境中被正确加锁和同步
        类的被动加载（不会发生类的初始化）：
            当访问一个静态域时，只有真正声明这个域的类才会被初始化
            通过数组定义类引用，不会触发此类的初始化  // A[] a = new A[10];
            引用常量不会触发此类的初始化（final）

    类加载器的层次结构：
        引导类加载器  扩展类加载器  引用程序类加载器  自定义类加载器
    代理模式：
        交给其他的类加载器来加载指定的类
        双亲委托机制（保证 Java 核心库的类型安全）：
            某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高层，
            如果父类加载器可以完成加载任务，就返回成功；只有当父类加载器无法完成加载时，才自己去加载。
            双亲委托机制是一种委托模式
    *被两个类加载器加载的同一个类，JVM 不认为是相同的类

    线程上下文类加载机制：
        Thread.currentThread().get/setContextClassLoader()

    Tomcat 服务器的类加载器机制：
        为每个 WEB 项目提供一个独立的类加载器

    OSGI：是面向 JAVA 的动态模块系统，为开发人员提供面向服务和基于组件的运行环境
        每个模块都有一个对应的一个类加载器  (Equinox)

四：正则表达式：一种强大而灵活的文本处理工具，通过规则来匹配字符串
    语法：
        普通字符        简单的转义字符
        标准字符集合(区分大小写，大写是相反的意思)：\d 、\w(匹配任意一个字母、数字或下划线) 、\s 、
            .(匹配任意一个字符，除了换行符)   // 匹配所有字符：使用[\s\S]
        自定义字符集合：[](匹配方括号中任意一个字符)
            正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^、- 之外
        量词：{n}、{m, n}、{m,}、? 相当于 {0,1}、+ 相当于 {1,}、*相当于 {0,}
            匹配模式默认是贪婪模式     非贪婪模式：在量词后加一个 ?
        字符边界(匹配位置)：^(与字符串开始的地方匹配)、$(与字符串结束的地方匹配)、\b(匹配一个单词边界)
            \b：前面的字符和后面的字符不全是 \w
        IGNORECASE：忽略大小写模式
        SINGLELINE：单行模式(整个文本看作一个字符串)
        MULTILINE：多行模式(匹配字符串的开始和结束位置可以使用 \A 和 \Z)
        选择符和分组：
            |：分支结构、"或"关系
            ()：捕获组      (?:Expression)：非捕获组
        反向引用(\nnn)：每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号
            通过反向引用，可以对分组已捕获的字符串进行引用
        预搜素(零宽断言)：是对位置的匹配
            零宽度：只进行子表达式的匹配，匹配内容不计入最终的匹配结果
            判断当前位置的前后字符，是否符合自定义的条件，但不匹配前后的字符
            (?=exp)  (?<=exp)  (?!exp)  (?<!exp)

        JAVA 中使用正则表达式：
            Pattern：正则表达式的编译表示形式
            Matcher：通过编译 Pattern 对字符串执行匹配操作的引擎

五：JDBC 数据库技术
    // mysql：describe tableName;  显示表的结构
    流程：加载 JDBC 驱动程序、建立与数据库的连接、发送 SQL 查询、获得查询结果
    Statement 接口：PreparedStatement    CallableStatement（用于调用存储过程）
    批处理：Batch  // 使用 Statement 处理效率高，也更安全
    事务处理：（特性：ACID）
        原子性、一致性、隔离性、持久性
        ①原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
        ②一致性（Consistency）
        事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
        ③隔离性（Isolation）
        事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
        ④持久性（Durability）
        一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。
    时间类型：Date、Time、Timestamp
    CLOB & BLOB：采用流的方式来处理
    使用propertiees文件存储 JDBC 连接信息：

六：ORM 框架
    核心架构：
        Query 接口：负责查询
        QueryFactory 工厂类：负责根据配置信息创建 Query 对象
        TypeConvertor 接口：负责类型转换（数据库类型和 java 类型之间的转化）
        TableContext：负责获取管理数据库所有表结构和类结构的关系，并可以根据表结构生成类结构
        DBManager：根据配置信息，维持连接对象的管理（增加连接池功能）
        工具类：
            SqlUtils：封装常用的 JDBC 操作        StringUtils：封装常用的字符串操作
            FileUtils：封装常用文件操作           ReflectUtils：封装常用反射操作
    核心 bean：
        ColumnInfo：封装表中一个字段的信息
        Configuration：封装配置文件信息
        TableInfo：封装一张表的信息
    连接池：事先存放多个连接对象(dbcp、c3p0、proxool)