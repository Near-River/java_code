设计模式：
创建型模式（关注对象的创建活动）
    单例模式、工厂模式、抽象工厂模式、创建者模式、原型模式

结构型模式（关注对象和类的组织）
    核心作用：从程序的结构上实现松耦合，从而可以扩大整体类结构，用来解决更大的问题
    适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

行为型模式（关注系统中对象之间的相互交互）
    研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责
    模板方法模式、命令模式、迭代模式、观察者模式、中介者模式、备忘录模式、解释器模式、
    状态模式、策略模式、职责链模式、访问者模式

    1：*单例模式
        保证一个类只有一个实例，并且提供一个访问该实例的全局访问点
        优点：减少系统性能开销，通过在应用启动时产生一个单例对象，然后永久驻留内存
        实现方式：
            饿汉式：线程安全、调用效率高、不支持延时加载    懒汉式：线程安全、调用效率高、支持延时加载
            双重检测锁模式：不推荐使用                    静态内部类的实现：兼备了并发调用和延迟加载的优势
            枚举方式实现单例：实现简单、不支持延时加载、避免了反射和反序列化的漏洞

    2：工厂模式（简单工厂模式、工厂方法模式、抽象工厂模式）
        实现了创建者和调用者分离，将选择实现类、创建对象统一管理和控制
        *简单工厂模式：
            用来生产同一等级结构中的任意产品（增加新产品，需要修改已有代码）
        工厂方法模式：
            用来生产同一等级结构中的固定产品（支持增加任意产品）
            不修改已有类的前提下，通过添加新的工厂类实现扩展

    3：抽象工厂模式：工厂方法模式的升级版
            用来生产不同产品族的全部产品（*支持增加产品族，不可增加新的产品）

    4：创建者模式：适用于创建复杂的对象，要分很多的步骤来处理
        本质：分离了对象子组件的单独构造（Builder 负责）和装配（Director 负责），从而构建出复杂的对象
            实现了构建和装配的解耦（构建算法和装配算法的解耦），可以实现更好的复用

    5：原型模式：JAVA 的克隆技术，以某个对象为原型，复制出新的对象。新的对象具备原型对象的特点
        优点：效率高、避免重复执行构造过程步骤。    克隆出来的对象改变不会影响原型对象
        实现：Cloneable 接口和 clone() 方法  // 一般与工厂方法模式结合使用
        // javascript 中的继承实现：prototype

    6：适配器模式
        实现方式：组合（对象适配器）  继承（类适配器）
        将一个类的接口转换为客户希望的另一个接口（使得原本由于接口不兼容而不能在一起工作的类可以一起工作）
        适配器：通过包装一个需要适配的对象，把原接口转换成目标接口
        需要适配的类(Adaptee)：需要适配的类或适配者类
        目标接口：客户希望的接口。目标可以是具体的或抽象的类，也可以是接口

    7：*代理模式（AOP 编程的核心实现机制）
        核心作用：通过代理，控制对对象的访问
                可以详细控制访问某个对象的方法，在调用这个方法前后做相应处理
        核心角色：
            抽象角色：定义代理角色和真实角色的公共对外方法
            真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。（关注真正的业务逻辑）
            代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，
                并可以附加自己的操作。 // 将统一的流程控制放到代理角色中处理
            应用场景：安全代理、远程代理、延迟加载
            分类：静态代理（静态定义代理类）    动态代理（动态生成代理类）

    8：桥接模式（目标：满足类的单一职责原则）
		将抽象化(Abstraction)与实现化(Implementation)脱耦
        处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，
        使各个维度可以独立的扩展在抽象层建立关联

    9：组合模式
        把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象
        核心：
            抽象构件(Component)角色：定义了叶子和容器构件的共同点
            叶子构件角色：无子节点
            容器构件(Composite)角色：有容器特征，可以包含子节点
        使用递归机制处理整个结构

    10：装饰模式(又称为包装器模式 wrapper)：动态的为一个对象增加或删除新的功能
        用于代替继承的技术，无需通过继承就可以扩展对象的新功能
        使用对象的关联关系代替继承关系，更加灵活（创造不同的行为组合），同时避免类型体系的快速膨胀
        使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类
        实现细节：
            Component 抽象构件角色：真实对象和装饰对象有相同的接口，
                这样客户端就能够以和真实对象相同的方式同装饰对象交互
            ConcreteComponent 具体构件角色（真实角色）：
            Decorator 装饰角色：持有一个抽象构件的引用，将客户端的请求转发给真实对象
            ConcreteDecorator 具体装饰角色：负责给构件对象增加新的责任

    11：*外观模式（门面模式）
        迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用
        为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用

    12：享元模式：以共享的方式高效地支持大量细粒度对象的重用
        实现的关键：区分内部状态和外部状态
            内部状态：可以共享，不会随环境变化而变化
            外部状态：不可以共享，会随环境变化而变化
        实现：
            FlyWeightFactory 享元工厂类：创建并管理享元对象，享元池一般设计成键值对
            FlyWeight 抽象享元类：接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，
                同时设置外部状态
            ConcreateFlyWeight 具体享元类：为内部状态提供成员变量进行存储
            UnsharedConcreteFlyWeight 非共享享元类：不能被共享的子类可以设计为非共享享元类
        优点：
            极大地减少内存对象的数量，提高系统性能
            外部状态相对独立，不影响内部状态

    13：职责链模式
        定义：能够处理同一个类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断
            是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象
        具体处理者、抽象处理者

    14：迭代器模式：提供一种遍历聚合对象的方式
        聚合对象：存储数据
        迭代器：遍历数据

    15：中介者模式：
        应用场景：如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系很复杂
        引入中介者对象，使各个同事对象只跟中介者对象打交道，将网状结构化解为星型结构
        本质：解耦多个同事对象之间的交互关系，每个同事对象都持有中介者对象的直接引用

    16：-命令模式（又称：动作模式、事物模式）
        将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化;
            对请求排队或者记录请求日志，以及支持可撤销的操作
        结构：Command 抽象命令类      ConcreteCommand 具体命令类
            Invoker 调用者/请求者：请求的发送者，通过命令对象来发送请求，和抽象命令类之间存在关联
            Receiver 接收者：执行与请求相关的操作，具体实现对请求的业务处理（是实际执行操作内容的对象）
            // 发送者和接收者之间没有关系，都通过命令对象来间接调用

    17：-解释器模式
        主要用于面向对象语言开发的编译器和解释器设计
        项目中使用 Jruby、Groovy、Java 的 js 引擎来替代解释器的作用

    18：-访问者模式
        定义：表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变元素的类的前提下
            定义作用于这些元素的新操作

    19：策略模式(strategy)
        对应于解决某个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，
        同时可以方便的更换算法或添加新的算法（并且由客户端决定调用哪个算法）
        本质：分离算法，选择实现

    20：*模板方法模式 +（回调函数）
        定义了一个算法的骨架，将某些步骤延迟到子类的实现，这样新的子类可以在不改变算法结构的前提下
            重新定义该算法的某些特定步骤
        核心：处理步骤父类中定义好，具体实现延迟到子类中定义
        子类不能调用父类，而通过父类调用子类

    21：状态模式
        核心：用于解决系统中的复杂对象的状态转换以及不同状态下行为的封装问题
        结构：
            Context 环境类：维护一个 State 对象，定义了当前对象
            State 抽象状态类
            ConcreteState 具体状态类：每一个类封装一个状态对应的行为

    22：观察者模式（应用于广播机制）
        把多个订阅者、客户称为观察者；把需要同步给多个订阅者的数据封装到对象中，称之为目标
        核心：用于 1:N 的通知，当一个对象（目标对象）发生状态变化时，该对象需要及时告知其他的
            对象（观察者对象），并令他们做出响应

    23：备忘录模式(memento)
        核心：保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态
        结构：
            源发器类 Originator：负责创建一个备忘录，可以记录当前时刻它的内部状态，
               并可使用备忘录恢复内部状态
            备忘录类 Memento：负责存储 Originator 对象的内部状态，并防止其他对象访问备忘录
            负责人类 CareTaker：负责保存好备忘录
        备忘点较多时：将备忘点压栈、对多个备忘录对象进行序列化和持久化